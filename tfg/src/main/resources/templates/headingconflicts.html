{{> fragments/header}}

<div class="hc-wrapper">
  <div class="hc-contenedor-flex">
    <div class="hc-juego">
      <h1 class="hc-titulo">¿Ves algún posible choque?</h1>
      <div class="hc-ronda" id="hc-ronda">Ronda 1 de 10</div>

      <div class="hc-grid" id="hc-grid"></div>

      
    </div>

    <!-- Lateral derecho: marcador + botones -->
    <div class="hc-lateral-derecha">
      <div class="coor-puntos marcador" id="coor-puntos">Puntos: 0</div>
      <div id="hc-feedback" class="hc-feedback"></div>
      <div class="hc-opciones">
        <button class="hc-boton" onclick="handleAnswer(true)">Hay conflicto</button>
        <button class="hc-boton" onclick="handleAnswer(false)">No hay conflicto</button>
      </div>
    </div>
  </div>
</div>

<div id="popup-final" class="coor-popup">
  <div class="coor-popup-content">
    <h2>🎉 Juego Terminado 🎉</h2>
    <p id="popup-puntos">Puntuación Total: 0 puntos</p>
    <div style="margin-top: 1.5rem;">
      <button onclick="reiniciarJuego()" class="popup-boton">Reiniciar</button>
      <button onclick="salirDelJuego()" class="popup-boton">Salir</button>
    </div>
  </div>
</div>
<script>
const gridCols = 15;
const gridRows = 10;
const directions = ['N', 'S', 'E', 'W'];
const directionAngles = { N: 0, E: 90, S: 180, W: 270 };

let planes = [];
let hasConflict = false;
let conflictPair = [];
let puntos = 0;
let ronda = 1;
const totalRondas = 10;
let mostrarConflicto = false;

function generatePlanes() {
  planes = [];
  conflictPair = [];
  mostrarConflicto = false;
  const totalPlanes = 20;
  const occupied = new Set();

  while (planes.length < totalPlanes) {
    const x = Math.floor(Math.random() * gridCols);
    const y = Math.floor(Math.random() * gridRows);
    const key = `${x},${y}`;
    if (!occupied.has(key)) {
      occupied.add(key);
      planes.push({
        id: planes.length + 1,
        x,
        y,
        heading: directions[Math.floor(Math.random() * directions.length)]
      });
    }
  }

  const result = buscarConflicto();
  hasConflict = result.found;
  conflictPair = result.pair;
}

function buscarConflicto() {
  for (let i = 0; i < planes.length; i++) {
    for (let j = i + 1; j < planes.length; j++) {
      if (sonConflicto(planes[i], planes[j], planes)) {
        return { found: true, pair: [planes[i].id, planes[j].id] };
      }
    }
  }
  return { found: false, pair: [] };
}

function sonConflicto(p1, p2, allPlanes) {
  const [x1, y1, h1] = [p1.x, p1.y, p1.heading];
  const [x2, y2, h2] = [p2.x, p2.y, p2.heading];

  // Conflicto horizontal: misma fila (y), opuestos (E-W)
  if (y1 === y2 && ((h1 === 'E' && h2 === 'W' && x1 < x2) || (h1 === 'W' && h2 === 'E' && x2 < x1))) {
    const minX = Math.min(x1, x2);
    const maxX = Math.max(x1, x2);
    // Comprobar si hay aviones entre ambos
    for (let plane of allPlanes) {
      if (plane.y === y1 && plane.x > minX && plane.x < maxX) {
        return false;
      }
    }
    return true;
  }

  // Conflicto vertical: misma columna (x), opuestos (N-S) con S *encima* de N
  if (x1 === x2 && ((h1 === 'N' && h2 === 'S' && y2 < y1) || (h1 === 'S' && h2 === 'N' && y1 < y2))) {
    const minY = Math.min(y1, y2);
    const maxY = Math.max(y1, y2);
    for (let plane of allPlanes) {
      if (plane.x === x1 && plane.y > minY && plane.y < maxY) {
        return false;
      }
    }
    return true;
  }

  return false;
}

function renderPlanes() {
  const grid = document.getElementById("hc-grid");
  grid.innerHTML = "";

  planes.forEach(plane => {
    const div = document.createElement("div");
    div.className = "hc-plane";
    if (mostrarConflicto && conflictPair.includes(plane.id)) {
      div.classList.add("conflict-plane");
    }

    div.style.gridColumnStart = plane.x + 1;
    div.style.gridRowStart = plane.y + 1;

    const img = document.createElement("img");
    img.src = "images/hc-plane.png"; 
    img.alt = "avión";
    img.className = "plane-icon";
    img.style.transform = `rotate(${directionAngles[plane.heading]}deg)`;

    div.appendChild(img);
    grid.appendChild(div);
  });
}


function handleAnswer(playerSaysConflict) {
  const feedback = document.getElementById("hc-feedback");
  mostrarConflicto = true;
  renderPlanes();

  if (playerSaysConflict === hasConflict) {
    puntos += 10;
    feedback.textContent = "¡Correcto! +10 puntos 🎉";
    feedback.style.color = "green";
  } else {
    puntos -= 5;
    feedback.textContent = "¡Incorrecto! -5 puntos ❌";
    feedback.style.color = "red";
  }

  ronda++;
  actualizarUI();

  if (ronda > totalRondas) {
    setTimeout(mostrarMensajeFinal, 1500);
  } else {
    setTimeout(() => {
      feedback.textContent = "";
      resetGame();
    }, 1500);
  }
}

function actualizarUI() {
  document.getElementById("coor-puntos").textContent = `Puntos: ${puntos}`;
  document.getElementById("hc-ronda").textContent = `Ronda ${Math.min(ronda, totalRondas)} de ${totalRondas}`;
}

function resetGame() {
  generatePlanes();
  renderPlanes();
}

function mostrarMensajeFinal() {
  const popup = document.getElementById("popup-final");
  const popupTexto = document.getElementById("popup-puntos");

  popupTexto.textContent = `Puntuación Total: ${puntos} puntos`;
  popup.style.display = "flex";
}

function reiniciarJuego() {
  const popup = document.getElementById("popup-final");
  popup.style.display = "none";
  puntos = 0;
  ronda = 1;
  actualizarUI();
  resetGame();
}

function salirDelJuego() {
  const popup = document.getElementById("popup-final");
  popup.style.display = "none";
  window.location.href = "principalJuegos";
}

actualizarUI();
resetGame();
</script>

{{> fragments/footer}}
